// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries_transaction.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transaction (
  quantity, type, destiny_location_id, origin_location_id,  material_id
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, quantity, type, origin_location_id, destiny_location_id, material_id, created_at
`

type CreateTransactionParams struct {
	Quantity          float32
	Type              Transactiontype
	DestinyLocationID uuid.UUID
	OriginLocationID  uuid.UUID
	MaterialID        uuid.UUID
}

type CreateTransactionRow struct {
	ID                uuid.UUID
	Quantity          float32
	Type              Transactiontype
	OriginLocationID  uuid.UUID
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (CreateTransactionRow, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Quantity,
		arg.Type,
		arg.DestinyLocationID,
		arg.OriginLocationID,
		arg.MaterialID,
	)
	var i CreateTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.Type,
		&i.OriginLocationID,
		&i.DestinyLocationID,
		&i.MaterialID,
		&i.CreatedAt,
	)
	return i, err
}

const createTransactionWithDL = `-- name: CreateTransactionWithDL :one
INSERT INTO transaction (
  quantity, type, destiny_location_id, material_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, quantity, type, origin_location_id, destiny_location_id, material_id, created_at
`

type CreateTransactionWithDLParams struct {
	Quantity          float32
	Type              Transactiontype
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
}

type CreateTransactionWithDLRow struct {
	ID                uuid.UUID
	Quantity          float32
	Type              Transactiontype
	OriginLocationID  uuid.UUID
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) CreateTransactionWithDL(ctx context.Context, arg CreateTransactionWithDLParams) (CreateTransactionWithDLRow, error) {
	row := q.db.QueryRow(ctx, createTransactionWithDL,
		arg.Quantity,
		arg.Type,
		arg.DestinyLocationID,
		arg.MaterialID,
	)
	var i CreateTransactionWithDLRow
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.Type,
		&i.OriginLocationID,
		&i.DestinyLocationID,
		&i.MaterialID,
		&i.CreatedAt,
	)
	return i, err
}

const createTransactionWithOL = `-- name: CreateTransactionWithOL :one
INSERT INTO transaction (
  quantity, type, origin_location_id, material_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, quantity, type, origin_location_id, destiny_location_id, material_id, created_at
`

type CreateTransactionWithOLParams struct {
	Quantity         float32
	Type             Transactiontype
	OriginLocationID uuid.UUID
	MaterialID       uuid.UUID
}

type CreateTransactionWithOLRow struct {
	ID                uuid.UUID
	Quantity          float32
	Type              Transactiontype
	OriginLocationID  uuid.UUID
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) CreateTransactionWithOL(ctx context.Context, arg CreateTransactionWithOLParams) (CreateTransactionWithOLRow, error) {
	row := q.db.QueryRow(ctx, createTransactionWithOL,
		arg.Quantity,
		arg.Type,
		arg.OriginLocationID,
		arg.MaterialID,
	)
	var i CreateTransactionWithOLRow
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.Type,
		&i.OriginLocationID,
		&i.DestinyLocationID,
		&i.MaterialID,
		&i.CreatedAt,
	)
	return i, err
}

const fetchPaginatedTransactions = `-- name: FetchPaginatedTransactions :many
SELECT id, quantity, type, origin_location_id, destiny_location_id, material_id, created_at FROM transaction
ORDER BY created_at LIMIT $1 OFFSET $2
`

type FetchPaginatedTransactionsParams struct {
	Limit  int32
	Offset int32
}

type FetchPaginatedTransactionsRow struct {
	ID                uuid.UUID
	Quantity          float32
	Type              Transactiontype
	OriginLocationID  uuid.UUID
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) FetchPaginatedTransactions(ctx context.Context, arg FetchPaginatedTransactionsParams) ([]FetchPaginatedTransactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchPaginatedTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPaginatedTransactionsRow
	for rows.Next() {
		var i FetchPaginatedTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Quantity,
			&i.Type,
			&i.OriginLocationID,
			&i.DestinyLocationID,
			&i.MaterialID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTransactionById = `-- name: FindTransactionById :one
SELECT id, quantity, type, origin_location_id, destiny_location_id, material_id, created_at FROM transaction
WHERE id = $1 LIMIT 1
`

type FindTransactionByIdRow struct {
	ID                uuid.UUID
	Quantity          float32
	Type              Transactiontype
	OriginLocationID  uuid.UUID
	DestinyLocationID uuid.UUID
	MaterialID        uuid.UUID
	CreatedAt         pgtype.Timestamp
}

func (q *Queries) FindTransactionById(ctx context.Context, id uuid.UUID) (FindTransactionByIdRow, error) {
	row := q.db.QueryRow(ctx, findTransactionById, id)
	var i FindTransactionByIdRow
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.Type,
		&i.OriginLocationID,
		&i.DestinyLocationID,
		&i.MaterialID,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionTableSize = `-- name: GetTransactionTableSize :one
SELECT count(*) AS exact_count FROM transaction
`

func (q *Queries) GetTransactionTableSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTransactionTableSize)
	var exact_count int64
	err := row.Scan(&exact_count)
	return exact_count, err
}

const fetchPaginatedTransactionsWithJson = `-- name: FetchPaginatedTransactionsWithJson :many
SELECT json_build_object(
    'id', transaction.id,
    'quantity', transaction.quantity,
    'created_at', transaction.created_at,
    'type', transaction.type,
    'material', json_build_object(
        'id', material.id,
        'name', material.name,
        'description', material.description,
        'quantity', material.quantity
    ),
    'origin', json_build_object(
        'id', origin.id,
        'name', origin.name
    ),
    'destiny', json_build_object(
        'id', destiny.id,
        'name', destiny.name
    )
)
FROM transaction
LEFT JOIN material ON transaction.material_id = material.id
LEFT JOIN location origin ON transaction.origin_location_id = origin.id
LEFT JOIN location destiny ON transaction.destiny_location_id = destiny.id
ORDER BY transaction.created_at LIMIT $1 OFFSET $2
`

type FetchPaginatedTransactionsWithJsonParams struct {
    Limit  int32
    Offset int32
}

func (q *Queries) FetchPaginatedTransactionsWithJson(ctx context.Context, arg FetchPaginatedTransactionsWithJsonParams) ([][]byte, error) {
    rows, err := q.db.Query(ctx, fetchPaginatedTransactionsWithJson, arg.Limit, arg.Offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var items [][]byte
    for rows.Next() {
        var json_build_object []byte
        if err := rows.Scan(&json_build_object); err != nil {
            return nil, err
        }
        items = append(items, json_build_object)
    }
    if err := rows.Err(); err != nil {
        return nil, err
    }
    return items, nil
}
