// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries_material.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const autocompleteMaterialByLikeName = `-- name: AutocompleteMaterialByLikeName :many
SELECT id, name, unit_id FROM material
WHERE name ~* $1 ORDER BY name ASC LIMIT 10
`

type AutocompleteMaterialByLikeNameRow struct {
	ID     uuid.UUID
	Name   string
	UnitID uuid.UUID
}

func (q *Queries) AutocompleteMaterialByLikeName(ctx context.Context, name string) ([]AutocompleteMaterialByLikeNameRow, error) {
	rows, err := q.db.Query(ctx, autocompleteMaterialByLikeName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AutocompleteMaterialByLikeNameRow
	for rows.Next() {
		var i AutocompleteMaterialByLikeNameRow
		if err := rows.Scan(&i.ID, &i.Name, &i.UnitID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createMaterial = `-- name: CreateMaterial :one
INSERT INTO material (
  name, description, category_id, unit_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, name, description, quantity, category_id, unit_id
`

type CreateMaterialParams struct {
	Name        string
	Description pgtype.Text
	CategoryID  uuid.UUID
	UnitID      uuid.UUID
}

func (q *Queries) CreateMaterial(ctx context.Context, arg CreateMaterialParams) (Material, error) {
	row := q.db.QueryRow(ctx, createMaterial,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.UnitID,
	)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Quantity,
		&i.CategoryID,
		&i.UnitID,
	)
	return i, err
}

const deleteMaterial = `-- name: DeleteMaterial :exec
DELETE FROM material
WHERE id = $1
`

func (q *Queries) DeleteMaterial(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMaterial, id)
	return err
}

const fetchMaterials = `-- name: FetchMaterials :many
SELECT id, name, description, quantity, category_id, unit_id FROM material
ORDER BY name
`

func (q *Queries) FetchMaterials(ctx context.Context) ([]Material, error) {
	rows, err := q.db.Query(ctx, fetchMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Quantity,
			&i.CategoryID,
			&i.UnitID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPaginatedMaterials = `-- name: FetchPaginatedMaterials :many
SELECT id, name, description, quantity, category_id, unit_id FROM material
ORDER BY name LIMIT $1 OFFSET $2
`

type FetchPaginatedMaterialsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) FetchPaginatedMaterials(ctx context.Context, arg FetchPaginatedMaterialsParams) ([]Material, error) {
	rows, err := q.db.Query(ctx, fetchPaginatedMaterials, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Quantity,
			&i.CategoryID,
			&i.UnitID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMaterialById = `-- name: FindMaterialById :one
SELECT id, name, description, quantity, category_id, unit_id FROM material
WHERE id = $1 LIMIT 1
`

func (q *Queries) FindMaterialById(ctx context.Context, id uuid.UUID) (Material, error) {
	row := q.db.QueryRow(ctx, findMaterialById, id)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Quantity,
		&i.CategoryID,
		&i.UnitID,
	)
	return i, err
}

const getMaterialTableSize = `-- name: GetMaterialTableSize :one
SELECT count(*) AS exact_count FROM material
`

func (q *Queries) GetMaterialTableSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getMaterialTableSize)
	var exact_count int64
	err := row.Scan(&exact_count)
	return exact_count, err
}

const updateMaterial = `-- name: UpdateMaterial :one
UPDATE material
  set name = $2,
  description = $3,
  category_id = $4,
  unit_id = $5
WHERE id = $1
RETURNING name, description, quantity, category_id, unit_id
`

type UpdateMaterialParams struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	CategoryID  uuid.UUID
	UnitID      uuid.UUID
}

type UpdateMaterialRow struct {
	Name        string
	Description pgtype.Text
	Quantity    float32
	CategoryID  uuid.UUID
	UnitID      uuid.UUID
}

func (q *Queries) UpdateMaterial(ctx context.Context, arg UpdateMaterialParams) (UpdateMaterialRow, error) {
	row := q.db.QueryRow(ctx, updateMaterial,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.UnitID,
	)
	var i UpdateMaterialRow
	err := row.Scan(
		&i.Name,
		&i.Description,
		&i.Quantity,
		&i.CategoryID,
		&i.UnitID,
	)
	return i, err
}

const updateMaterialQuantity = `-- name: UpdateMaterialQuantity :exec
UPDATE material
  set quantity = $2
WHERE id = $1
`

type UpdateMaterialQuantityParams struct {
	ID       uuid.UUID
	Quantity float32
}

func (q *Queries) UpdateMaterialQuantity(ctx context.Context, arg UpdateMaterialQuantityParams) error {
	_, err := q.db.Exec(ctx, updateMaterialQuantity, arg.ID, arg.Quantity)
	return err
}
